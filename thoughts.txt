- data versioning, branching, merging
- multiple inheritance
- snel
- object-georienteerde revisies
- multilingual
- sets
- lists
- typen hebben geen intrinsieke 'semantische' eigenschappen, zoals naam of titel
- typen kun je in de code hernoemen zonder dat er iets in de database hoeft te veranderen
- bij een (zware) update actie wordt de repo gelockd. Als er dan een actie wordt uitgevoerd, krijgt de gebruiker een foutmelding ('probeer het nog eens').
- gebruik geen string-constanten in applicatie code
- het is ok dat je een business object niet mag wijzigen. De business rules horen elders. Waar?
- het is een idee dat de gebruiker helemaal niet queriet uit de triple tabellen. alleen de views zijn toegestaan.
- foutmeldingen: overal exceptions
- een object krijgt bij creatie al een id
- alle typen van een object worden opgeslagen in de database, maar als een object wordt geinitialiseerd is dat altijd vanuit 1 type. Het object heeft dan geen weet van zijn andere typen;
    je instantieert dus een 'interpretatie', een 'view' van het object
- attribute en attribute definition is nu nog hetzelfde ding
- verschillende typen kunnen attributen delen. Ik wil dat volledige ongerelateerde typen (niet verbonden door een gemeenschappelijke ouder) toch dezelfde attribuut kunnen hebben
    (niet alleen de naam, echt dezelfde) Voorbeeld-attribuut: date modified
- object-level locking
- ook te implementeren als gedistribueerde database? evt
- prevent double triples by locking; ook geen arrays?
- nieuw datatype: reference (uuid)?
- customization: de gebruiker moet ook overal bijkunnen en aanpassen
- DummyViewStore voor als create-views = 0; idem voor andere features

# Definitions

- TypeDefinition: conceptual level representation of a type. It has attributes with names, but no ids.
- Type: storage level representation of a type. It has ids.

# todo

integrate:

        $classCreator->createClasses(CustomerPicket::class, $type);
        $viewCreator->createView(new CustomerType());


# Revisiebeheer

- elke revisie is een patch, een diff van triples
- elke revisie is ook een set van gewijzigde objecten
- in een revisie kan een object ook voorkomen als de waarde van een referentie attribuut
- je kunt per object zijn laatste revisie bijhouden, gelinkte lijst

Er geldt:

- een revisie mag pas worden ongedaan gemaakt als de objecten die erin voorkomen als onderwerp of referentie, niet later nog terugkomen in een andere revisie
- revision id, index (volgnr triples), triple, action
- revisies zijn geordend; tijdstip alleen is niet voldoende

New revision:

- time
- object-ids
- triple-ids

indra_revision_object
- object
- revision-id
- previous-revision-id

wat gebeurt er als je een revisie ongedaan maakt?

Een object opslaan kan via de model. Objecten van meerdere typen ineens opslaan kan met:
Context::getRevisionStore()->saveMultiple([$customer, $description);

Als je meerdere revisies in 1 request toelaat, kun je dan geen circulaire dependencies maken?

- r1: A.ref = C
- r2: C.ref = A
- save r1
- save r2
- draai r2 terug => r1 is stuk? nee

- r1: A.attr = x
- r2: delete A
- r3: A.attr = y
- save r1
- save r2
- draai r2 terug => r1 is stuk? ja

Dat is stuk, maar ook niet waarschijnlijk in een request. En daarnaast kan de triple store hier op controleren; net voor het opslaan.

Nee dat is niet stuk. De triple store haalt net voor het opslaan het oude object op. Bij het opslaan worden alle attributen (mogelijk opnieuw) geschreven.

# Tiers

- definition: type creation and management (setup and upgrade)
- storage: triple store (bevat alle informatie over opslag in MySql)
- application: php classes, my module

- service: overkoepelend (de enige interface van de applicatieprogrammeur met het systeem)

Idee

// $configuration bevat de dependencies
// indra is de hoofdindex voor definition
$indra = new indra($configuration);
$indra->createClasses();
$indra->createView();
$indra->createTables();

Slecht idee, want je kan dat hier wel doen, maar niet bij bij bv. new CustomerModel();

# Views

insert -> add to all views
update -> update to all views
remove -> remove from all views
insert revision undo -> remove from all views
update revision undo -> update all views
remove revision undo -> add to all views

Een revisie mag alleen ongedaan worden als het objecten bevat die daarna niet meer voorkomen in andere revisies.

Voorbeeld view:

Customer

- name

Category

- name.fr_FR
- name.en_EN

Customer

- parents

Misschien moet je array-attributen maar gewoon uitsluiten... je kunt ze niet materialiseren.
Je kunt hier misschien andere constructies voor maken.

Objecten opslaan als JSON?

uuid uuid uuid int
uuid uuid uuid varchar
uuid uuid uuid text
uuid uuid uuid date
uuid uuid uuid datetime
uuid uuid uuid time

table indra_active_int;
table indra_passive_int;

table indra_revision;
timestamp
triple_id
action: add/remove
description

table indra_revision_triple;
triple_id, time,

table indra_revision_int;
