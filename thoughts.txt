- data versioning, branching, merging
- multiple inheritance
- snel
- object-georienteerde revisies
- multilingual
- sets
- lists
- typen hebben geen intrinsieke 'semantische' eigenschappen, zoals naam of titel
- typen kun je in de code hernoemen zonder dat er iets in de database hoeft te veranderen
- bij een (zware) update actie wordt de repo gelockd. Als er dan een actie wordt uitgevoerd, krijgt de gebruiker een foutmelding ('probeer het nog eens').
- gebruik geen string-constanten in applicatie code
- het is ok dat je een business object niet mag wijzigen. De business rules horen elders. Waar?
- het is een idee dat de gebruiker helemaal niet queriet uit de triple tabellen. alleen de views zijn toegestaan.
- foutmeldingen: overal exceptions
- een object krijgt bij creatie al een id
- alle typen van een object worden opgeslagen in de database, maar als een object wordt geinitialiseerd is dat altijd vanuit 1 type. Het object heeft dan geen weet van zijn andere typen;
    je instantieert dus een 'interpretatie', een 'view' van het object
- attribute en attribute definition is nu nog hetzelfde ding
- verschillende typen kunnen attributen delen. Ik wil dat volledige ongerelateerde typen (niet verbonden door een gemeenschappelijke ouder) toch dezelfde attribuut kunnen hebben
    (niet alleen de naam, echt dezelfde) Voorbeeld-attribuut: date modified
- object-level locking
- ook te implementeren als gedistribueerde database? evt
- prevent double triples by locking; ook geen arrays?
- nieuw datatype: reference (uuid)?
- customization: de gebruiker moet ook overal bijkunnen en aanpassen
- DummyViewStore voor als create-views = 0; idem voor andere features
- Ik denk aan een decorator pattern voor geneste contexten: Context / Branch / Revision / Model
- opgesplitst: Context (voor systeem-dependencies) en Domain (voor domein-specifieke dependencies)

# Definitions

- TypeDefinition: conceptual level representation of a type. It has attributes with names, but no ids.
- Type: storage level representation of a type. It has ids.

# branching en merging

- tabel indra_branch (branch_id, source_id, user_id, time)
- oh, ja nieuwe tabel voor indra gebruikers: indra_user(user_id, extra_id, name) // extra_id koppelt de gebruiker aan een ander pakket
- neem ook de branch_id op in de user?
- veralgemeniseer de inactive tabel voor alle niet-master branches?
    nee, beter is denk ik een indra_branch_int, indra_branch_varchar, ... voor de actieve niet-master triples
    ook mogelijk is een branch_id toevoegen aan de triple tabellen; voor de onderhoudbaarheid het makkelijkst;
        is wel jammer als geen branching wordt gebruikt; en overigens over het algemeen dataverspilling
- revisie moet ook worden uitgebreid met branch_id
- merge branch b1 in b2: voor alle objecten in branch b1, zoek eerst het object in b2, overschrijf de waarden met die in b1. schrijf weg
- maak view-tabellen aan on-demand: als er voor het eerst om gevraagd wordt.
- aanmaken view: 1) haal alle ids op; 2) bouw alle objecten op met (getCustomer(id)) of met getCustomers()). Voor iedere customer wordt dan eerst
    gekeken of die in de huidige branch bestaat, en zo niet: in de source branch (probleem: hij kan verwijderd zijn in de huidige branch)
- er wordt NIET gequeried in de triple store (behalve voor het opbouwen van views, natuurlijk)
- branches worden niet verwijderd als ze gemergd worden

# todo

integrate:

        $classCreator->createClasses(CustomerPicket::class, $type);
        $viewCreator->createView(new CustomerType());


# Revisiebeheer

- elke revisie is een patch, een diff van triples
- elke revisie is ook een set van gewijzigde objecten
- in een revisie kan een object ook voorkomen als de waarde van een referentie attribuut
- je kunt per object zijn laatste revisie bijhouden, gelinkte lijst

Er geldt:

- een revisie mag pas worden ongedaan gemaakt als de objecten die erin voorkomen als onderwerp of referentie, niet later nog terugkomen in een andere revisie
- revision id, index (volgnr triples), triple, action
- revisies zijn geordend; tijdstip alleen is niet voldoende

New revision:

- time
- object-ids
- triple-ids

indra_revision_object
- object
- revision-id
- previous-revision-id

wat gebeurt er als je een revisie ongedaan maakt?

Een object opslaan kan via de model. Objecten van meerdere typen ineens opslaan kan met:
Context::getRevisionStore()->saveMultiple([$customer, $description);

Als je meerdere revisies in 1 request toelaat, kun je dan geen circulaire dependencies maken?

- r1: A.ref = C
- r2: C.ref = A
- save r1
- save r2
- draai r2 terug => r1 is stuk? nee

- r1: A.attr = x
- r2: delete A
- r3: A.attr = y
- save r1
- save r2
- draai r2 terug => r1 is stuk? ja

Dat is stuk, maar ook niet waarschijnlijk in een request. En daarnaast kan de triple store hier op controleren; net voor het opslaan.

Nee dat is niet stuk. De triple store haalt net voor het opslaan het oude object op. Bij het opslaan worden alle attributen (mogelijk opnieuw) geschreven.

# Tiers

- definition: type creation and management (setup and upgrade)
- storage: triple store (bevat alle informatie over opslag in MySql)
- application: php classes, my module

- service: overkoepelend (de enige interface van de applicatieprogrammeur met het systeem)

Idee

// $configuration bevat de dependencies
// indra is de hoofdindex voor definition
$indra = new indra($configuration);
$indra->createClasses();
$indra->createView();
$indra->createTables();

Slecht idee, want je kan dat hier wel doen, maar niet bij bij bv. new CustomerModel();

# Views

insert -> add to all views
update -> update to all views
remove -> remove from all views
insert revision undo -> remove from all views
update revision undo -> update all views
remove revision undo -> add to all views

Een revisie mag alleen ongedaan worden als het objecten bevat die daarna niet meer voorkomen in andere revisies.

Voorbeeld view:

Customer

- name

Category

- name.fr_FR
- name.en_EN

Customer

- parents

Misschien moet je array-attributen maar gewoon uitsluiten... je kunt ze niet materialiseren.
Je kunt hier misschien andere constructies voor maken.

Objecten opslaan als JSON?

uuid uuid uuid int
uuid uuid uuid varchar
uuid uuid uuid text
uuid uuid uuid date
uuid uuid uuid datetime
uuid uuid uuid time

table indra_active_int;
table indra_passive_int;

table indra_revision;
timestamp
triple_id
action: add/remove
description

table indra_revision_triple;
triple_id, time,

table indra_revision_int;

# en verder

- beetje jammer een 22-byte id voor attributen; kan wel wat minder
