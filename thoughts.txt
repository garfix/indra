- data versioning, branching, merging
- multiple inheritance
- snel
- object-georienteerde revisies
- multilingual
- sets
- lists
- typen hebben geen intrinsieke 'semantische' eigenschappen, zoals naam of titel
- typen kun je in de code hernoemen zonder dat er iets in de database hoeft te veranderen
- bij een (zware) update actie wordt de repo gelockd. Als er dan een actie wordt uitgevoerd, krijgt de gebruiker een foutmelding ('probeer het nog eens').
- gebruik geen string-constanten in applicatie code
- het is ok dat je een business object niet mag wijzigen. De business rules horen elders. Waar?
- het is een idee dat de gebruiker helemaal niet queriet uit de triple tabellen. alleen de views zijn toegestaan.
- foutmeldingen: overal exceptions
- een object krijgt bij creatie al een id
- alle typen van een object worden opgeslagen in de database, maar als een object wordt geinitialiseerd is dat altijd vanuit 1 type. Het object heeft dan geen weet van zijn andere typen;
    je instantieert dus een 'interpretatie', een 'view' van het object
- attribute en attribute definition is nu nog hetzelfde ding
- verschillende typen kunnen attributen delen. Ik wil dat volledige ongerelateerde typen (niet verbonden door een gemeenschappelijke ouder) toch dezelfde attribuut kunnen hebben
    (niet alleen de naam, echt dezelfde) Voorbeeld-attribuut: date modified
- object-level locking
- met loadCustomers($ids) meerdere customers, maar ook subklassen in 1x kunnen laden
- ook te implementeren als gedistribueerde database? evt
- prevent double triples by locking; ook geen arrays?
- nieuw datatype: reference (uuid)?
- customization: de gebruiker moet ook overal bijkunnen en aanpassen
- DummyViewStore voor als create-views = 0; idem voor andere features
- Ik denk aan een decorator pattern voor geneste contexten: Context / Branch / Revision / Model
- opgesplitst: Context (voor systeem-dependencies) en Domain (voor domein-specifieke dependencies)
- ik wil objecten eigenlijk niet verzamelen in een save-list bij een revision, ik wil dat ze meteen opgeslagen worden. Op die manier kun je ze meteen gebruiken in een query.
- aan de andere kant is het heel goed om alle wijzigingen eerst te verzamelen voordat ze worden weggeschreven. objecten die eerst gewijzigd worden en daarna verwijderd bijvoorbeeld. De wijzigingen wil je dan niet opslaan.

- Branchmodel en revisionmodel mogen eruit.

# Definitions

- TypeDefinition: conceptual level representation of a type. It has attributes with names, but no ids.
- Type: storage level representation of a type. It has ids.

# branching en merging

- tabel indra_branch (branch_id, source_id, user_id, time)
- oh, ja nieuwe tabel voor indra gebruikers: indra_user(user_id, extra_id, name) // extra_id koppelt de gebruiker aan een ander pakket
- neem ook de branch_id op in de user?
- veralgemeniseer de inactive tabel voor alle niet-master branches?
    nee, beter is denk ik een indra_branch_int, indra_branch_varchar, ... voor de actieve niet-master triples
    ook mogelijk is een branch_id toevoegen aan de triple tabellen; voor de onderhoudbaarheid het makkelijkst;
        is wel jammer als geen branching wordt gebruikt; en overigens over het algemeen dataverspilling
- revisie moet ook worden uitgebreid met branch_id
- merge branch b1 in b2: voor alle objecten in branch b1, zoek eerst het object in b2, overschrijf de waarden met die in b1. schrijf weg
- maak view-tabellen aan on-demand: als er voor het eerst om gevraagd wordt.
- aanmaken view: 1) haal alle ids op; 2) bouw alle objecten op met (getCustomer(id)) of met getCustomers()). Voor iedere customer wordt dan eerst
    gekeken of die in de huidige branch bestaat, en zo niet: in de source branch (probleem: hij kan verwijderd zijn in de huidige branch)
- er wordt NIET gequeried in de triple store (behalve voor het opbouwen van views, natuurlijk)
- branches worden niet verwijderd als ze gemergd worden

# Merge


!! HIERO !!

neem $fromActive en $toActive parameters op in de activateTriple functies
maar eigenlijk wil je dit met minder gedoe
maar eerst de unit tests werkend krijgen!


- Een branch is technisch gezien alleen een tag van een revisie.
- NB: een revisie heeft GEEN branch verwijzing; een branch heeft een revisie verwijzing
- Iedere revisie heeft een verwijzing naar een eerdere revisie.

Bij het mergen van b1 naar b2:

- Zoek terug in b1
- Zoek terug in b2
- Vind de eerste gemeenschappelijke revisie rg
- In chrono volgorde: pas de revisies van b1 na rg toe op b2
- Al deze acties komen in een nieuwe revisie terecht: rn (dit is de merge-commit)
- rn wordt toegevoegd aan b2
- b1 wordt gekoppeld aan dezelfde revisie als b2

# todo

integrate:

        $classCreator->createClasses(CustomerPicket::class, $type);
        $viewCreator->createView(new CustomerType());

# $customerModel->saveCustomer($customer);

$customerModel->saveCustomer($customer);

Als er geen revisie actief is wordt $customer meteen opgeslagen

Als er wel een revisie actief is wordt $customer toegevoegd aan de saveList van de revisie

# Revisiebeheer

- elke revisie is een patch, een diff van triples
- elke revisie is ook een set van gewijzigde objecten
- in een revisie kan een object ook voorkomen als de waarde van een referentie attribuut
- je kunt per object zijn laatste revisie bijhouden, gelinkte lijst

Er geldt:

- een revisie mag pas worden ongedaan gemaakt als de objecten die erin voorkomen als onderwerp of referentie, niet later nog terugkomen in een andere revisie
- revision id, index (volgnr triples), triple, action
- revisies zijn geordend; tijdstip alleen is niet voldoende

New revision:

- time
- object-ids
- triple-ids

indra_revision_object
- object
- revision-id
- previous-revision-id

wat gebeurt er als je een revisie ongedaan maakt?

Een object opslaan kan via de model. Objecten van meerdere typen ineens opslaan kan met:
Context::getRevisionStore()->saveMultiple([$customer, $description);

Als je meerdere revisies in 1 request toelaat, kun je dan geen circulaire dependencies maken?

- r1: A.ref = C
- r2: C.ref = A
- save r1
- save r2
- draai r2 terug => r1 is stuk? nee

- r1: A.attr = x
- r2: delete A
- r3: A.attr = y
- save r1
- save r2
- draai r2 terug => r1 is stuk? ja

Dat is stuk, maar ook niet waarschijnlijk in een request. En daarnaast kan de triple store hier op controleren; net voor het opslaan.

Nee dat is niet stuk. De triple store haalt net voor het opslaan het oude object op. Bij het opslaan worden alle attributen (mogelijk opnieuw) geschreven.

- Het is niet mogelijk tabel-wijzigingen in een revisie op te nemen
- De data is afhankelijk van de code. Beter gezegd: applicatie-data is afhankelijk van definitie data.
    In de database staat data die alleen gemaakt kon worden met code die door definitie-code is gemaakt. Als de definitie code verandert, en dus de applicatie-code,
    dan kun je de oude data van de database niet (helemaal) meer gebruiken.
- Dit is niet superbelangrijk, maar je moet er wel wat mee.

# Tiers

Houd deze tiers strikt gescheiden: effecten van acties in de 1 hebben invloed op die van andere tiers

- definition: type creation and management (setup and upgrade)
- storage: triple store (bevat alle informatie over opslag in MySql)
- application: php classes, my module
- branching en merging

- service: overkoepelend (de enige interface van de applicatieprogrammeur met het systeem)

Idee

// $configuration bevat de dependencies
// indra is de hoofdindex voor definition
$indra = new indra($configuration);
$indra->createClasses();
$indra->createView();
$indra->createTables();

Slecht idee, want je kan dat hier wel doen, maar niet bij bij bv. new CustomerModel();

# Views

insert -> add to all views
update -> update to all views
remove -> remove from all views
insert revision undo -> remove from all views
update revision undo -> update all views
remove revision undo -> add to all views

Een revisie mag alleen ongedaan worden als het objecten bevat die daarna niet meer voorkomen in andere revisies.

Voorbeeld view:

Customer

- name

Category

- name.fr_FR
- name.en_EN

Customer

- parents

Misschien moet je array-attributen maar gewoon uitsluiten... je kunt ze niet materialiseren.
Je kunt hier misschien andere constructies voor maken.

Objecten opslaan als JSON?

uuid uuid uuid int
uuid uuid uuid varchar
uuid uuid uuid text
uuid uuid uuid date
uuid uuid uuid datetime
uuid uuid uuid time

table indra_active_int;
table indra_passive_int;

table indra_revision;
timestamp
triple_id
action: add/remove
description

table indra_revision_triple;
triple_id, time,

table indra_revision_int;

# en verder

- beetje jammer een 22-byte id voor attributen; kan wel wat minder

#        $revision->addToSaveList($customer);
//$domain->getRevisionModel()->storeRevision($revision);
//$domain->getBranchModel()->storeBranchRevision($branch, $revision);

# check out

- http://www.liquibase.org/
- https://exversiondata.wordpress.com/2013/08/27/version-control-for-data/

